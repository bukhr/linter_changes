# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activesupport` gem.
# Please instead update this file by running `bin/tapioca gem activesupport`.


# :include: ../README.rdoc
#
# source://activesupport//lib/active_support/hash_with_indifferent_access.rb#8
module ActiveSupport; end

# source://activesupport//lib/active_support/delegation.rb#16
module ActiveSupport::Delegation
  class << self
    # source://activesupport//lib/active_support/delegation.rb#23
    def generate(owner, methods, location: T.unsafe(nil), to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil), nilable: T.unsafe(nil), private: T.unsafe(nil), as: T.unsafe(nil), signature: T.unsafe(nil)); end

    # source://activesupport//lib/active_support/delegation.rb#152
    def generate_method_missing(owner, target, allow_nil: T.unsafe(nil)); end
  end
end

# source://activesupport//lib/active_support/delegation.rb#20
ActiveSupport::Delegation::RESERVED_METHOD_NAMES = T.let(T.unsafe(nil), Set)

# source://activesupport//lib/active_support/delegation.rb#17
ActiveSupport::Delegation::RUBY_RESERVED_KEYWORDS = T.let(T.unsafe(nil), Array)

# Error generated by +delegate+ when a method is called on +nil+ and +allow_nil+
# option is not used.
#
# source://activesupport//lib/active_support/delegation.rb#8
class ActiveSupport::DelegationError < ::NoMethodError
  class << self
    # source://activesupport//lib/active_support/delegation.rb#10
    def nil_target(method_name, target); end
  end
end

# = \Hash With Indifferent Access
#
# Implements a hash where keys <tt>:foo</tt> and <tt>"foo"</tt> are considered
# to be the same.
#
#   rgb = ActiveSupport::HashWithIndifferentAccess.new
#
#   rgb[:black] = '#000000'
#   rgb[:black]  # => '#000000'
#   rgb['black'] # => '#000000'
#
#   rgb['white'] = '#FFFFFF'
#   rgb[:white]  # => '#FFFFFF'
#   rgb['white'] # => '#FFFFFF'
#
# Internally symbols are mapped to strings when used as keys in the entire
# writing interface (calling <tt>[]=</tt>, <tt>merge</tt>, etc). This
# mapping belongs to the public interface. For example, given:
#
#   hash = ActiveSupport::HashWithIndifferentAccess.new(a: 1)
#
# You are guaranteed that the key is returned as a string:
#
#   hash.keys # => ["a"]
#
# Technically other types of keys are accepted:
#
#   hash = ActiveSupport::HashWithIndifferentAccess.new(a: 1)
#   hash[0] = 0
#   hash # => {"a"=>1, 0=>0}
#
# but this class is intended for use cases where strings or symbols are the
# expected keys and it is convenient to understand both as the same. For
# example the +params+ hash in Ruby on \Rails.
#
# Note that core extensions define <tt>Hash#with_indifferent_access</tt>:
#
#   rgb = { black: '#000000', white: '#FFFFFF' }.with_indifferent_access
#
# which may be handy.
#
# To access this class outside of \Rails, require the core extension with:
#
#   require "active_support/core_ext/hash/indifferent_access"
#
# which will, in turn, require this file.
#
# source://activesupport//lib/active_support/hash_with_indifferent_access.rb#55
class ActiveSupport::HashWithIndifferentAccess < ::Hash
  # @return [HashWithIndifferentAccess] a new instance of HashWithIndifferentAccess
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#70
  def initialize(constructor = T.unsafe(nil)); end

  # Same as <tt>Hash#[]</tt> where the key passed as argument can be
  # either a string or a symbol:
  #
  #   counters = ActiveSupport::HashWithIndifferentAccess.new
  #   counters[:foo] = 1
  #
  #   counters['foo'] # => 1
  #   counters[:foo]  # => 1
  #   counters[:zoo]  # => nil
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#168
  def [](key); end

  # Assigns a new value to the hash:
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new
  #   hash[:key] = 'value'
  #
  # This value can be later fetched using either +:key+ or <tt>'key'</tt>.
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#98
  def []=(key, value); end

  # Same as <tt>Hash#assoc</tt> where the key passed as argument can be
  # either a string or a symbol:
  #
  #   counters = ActiveSupport::HashWithIndifferentAccess.new
  #   counters[:foo] = 1
  #
  #   counters.assoc('foo') # => ["foo", 1]
  #   counters.assoc(:foo)  # => ["foo", 1]
  #   counters.assoc(:zoo)  # => nil
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#181
  def assoc(key); end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#375
  def compact; end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#319
  def deep_stringify_keys; end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#317
  def deep_stringify_keys!; end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#324
  def deep_symbolize_keys; end

  # Same as <tt>Hash#default</tt> where the key passed as argument can be
  # either a string or a symbol:
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new(1)
  #   hash.default                   # => 1
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new { |hash, key| key }
  #   hash.default                   # => nil
  #   hash.default('foo')            # => 'foo'
  #   hash.default(:foo)             # => 'foo'
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#223
  def default(key = T.unsafe(nil)); end

  # Removes the specified key from the hash.
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#303
  def delete(key); end

  # Same as <tt>Hash#dig</tt> where the key passed as argument can be
  # either a string or a symbol:
  #
  #   counters = ActiveSupport::HashWithIndifferentAccess.new
  #   counters[:foo] = { bar: 1 }
  #
  #   counters.dig('foo', 'bar')     # => 1
  #   counters.dig(:foo, :bar)       # => 1
  #   counters.dig(:zoo)             # => nil
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#208
  def dig(*args); end

  # Returns a shallow copy of the hash.
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new({ a: { b: 'b' } })
  #   dup  = hash.dup
  #   dup[:a][:c] = 'c'
  #
  #   hash[:a][:c] # => "c"
  #   dup[:a][:c]  # => "c"
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#264
  def dup; end

  # Returns a hash with indifferent access that includes everything except given keys.
  #   hash = { a: "x", b: "y", c: 10 }.with_indifferent_access
  #   hash.except(:a, "b") # => {c: 10}.with_indifferent_access
  #   hash                 # => { a: "x", b: "y", c: 10 }.with_indifferent_access
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#311
  def except(*keys); end

  # Returns +true+ so that <tt>Array#extract_options!</tt> finds members of
  # this class.
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#58
  def extractable_options?; end

  # Same as <tt>Hash#fetch</tt> where the key passed as argument can be
  # either a string or a symbol:
  #
  #   counters = ActiveSupport::HashWithIndifferentAccess.new
  #   counters[:foo] = 1
  #
  #   counters.fetch('foo')          # => 1
  #   counters.fetch(:bar, 0)        # => 0
  #   counters.fetch(:bar) { |key| 0 } # => 0
  #   counters.fetch(:zoo)           # => KeyError: key not found: "zoo"
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#195
  def fetch(key, *extras); end

  # Returns an array of the values at the specified indices, but also
  # raises an exception when one of the keys can't be found.
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new
  #   hash[:a] = 'x'
  #   hash[:b] = 'y'
  #   hash.fetch_values('a', 'b') # => ["x", "y"]
  #   hash.fetch_values('a', 'c') { |key| 'z' } # => ["x", "z"]
  #   hash.fetch_values('a', 'c') # => KeyError: key not found: "c"
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#251
  def fetch_values(*indices, &block); end

  # Checks the hash for a key matching the argument passed in:
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new
  #   hash['key'] = 'value'
  #   hash.key?(:key)  # => true
  #   hash.key?('key') # => true
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#151
  def has_key?(key); end

  # Checks the hash for a key matching the argument passed in:
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new
  #   hash['key'] = 'value'
  #   hash.key?(:key)  # => true
  #   hash.key?('key') # => true
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#151
  def include?(key); end

  # Checks the hash for a key matching the argument passed in:
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new
  #   hash['key'] = 'value'
  #   hash.key?(:key)  # => true
  #   hash.key?('key') # => true
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#151
  def key?(key); end

  # Checks the hash for a key matching the argument passed in:
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new
  #   hash['key'] = 'value'
  #   hash.key?(:key)  # => true
  #   hash.key?('key') # => true
  #
  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#151
  def member?(key); end

  # This method has the same semantics of +update+, except it does not
  # modify the receiver but rather returns a new hash with indifferent
  # access with the result of the merge.
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#273
  def merge(*hashes, &block); end

  # Updates the receiver in-place, merging in the hashes passed as arguments:
  #
  #   hash_1 = ActiveSupport::HashWithIndifferentAccess.new
  #   hash_1[:key] = 'value'
  #
  #   hash_2 = ActiveSupport::HashWithIndifferentAccess.new
  #   hash_2[:key] = 'New Value!'
  #
  #   hash_1.update(hash_2) # => {"key"=>"New Value!"}
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new
  #   hash.update({ "a" => 1 }, { "b" => 2 }) # => { "a" => 1, "b" => 2 }
  #
  # The arguments can be either an
  # +ActiveSupport::HashWithIndifferentAccess+ or a regular +Hash+.
  # In either case the merge respects the semantics of indifferent access.
  #
  # If the argument is a regular hash with keys +:key+ and <tt>"key"</tt> only one
  # of the values end up in the receiver, but which one is unspecified.
  #
  # When given a block, the value for duplicated keys will be determined
  # by the result of invoking the block with the duplicated key, the value
  # in the receiver, and the value in +other_hash+. The rules for duplicated
  # keys follow the semantics of indifferent access:
  #
  #   hash_1[:key] = 10
  #   hash_2['key'] = 12
  #   hash_1.update(hash_2) { |key, old, new| old + new } # => {"key"=>22}
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#132
  def merge!(*other_hashes, &block); end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#66
  def nested_under_indifferent_access; end

  def regular_update(*_arg0); end
  def regular_writer(_arg0, _arg1); end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#332
  def reject(*args, &block); end

  # Replaces the contents of this hash with other_hash.
  #
  #   h = { "a" => 100, "b" => 200 }
  #   h.replace({ "c" => 300, "d" => 400 }) # => {"c"=>300, "d"=>400}
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#298
  def replace(other_hash); end

  # Like +merge+ but the other way around: Merges the receiver into the
  # argument and returns a new hash with indifferent access as result:
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new
  #   hash['a'] = nil
  #   hash.reverse_merge(a: 0, b: 1) # => {"a"=>nil, "b"=>1}
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#283
  def reverse_merge(other_hash); end

  # Same semantics as +reverse_merge+ but modifies the receiver in-place.
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#289
  def reverse_merge!(other_hash); end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#327
  def select(*args, &block); end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#365
  def slice(*keys); end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#370
  def slice!(*keys); end

  # Assigns a new value to the hash:
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new
  #   hash[:key] = 'value'
  #
  # This value can be later fetched using either +:key+ or <tt>'key'</tt>.
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#98
  def store(key, value); end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#318
  def stringify_keys; end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#316
  def stringify_keys!; end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#322
  def symbolize_keys; end

  # Convert to a regular hash with string keys.
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#380
  def to_hash; end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#322
  def to_options; end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#325
  def to_options!; end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#390
  def to_proc; end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#344
  def transform_keys(hash = T.unsafe(nil), &block); end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#349
  def transform_keys!(hash = T.unsafe(nil), &block); end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#337
  def transform_values(&block); end

  # Updates the receiver in-place, merging in the hashes passed as arguments:
  #
  #   hash_1 = ActiveSupport::HashWithIndifferentAccess.new
  #   hash_1[:key] = 'value'
  #
  #   hash_2 = ActiveSupport::HashWithIndifferentAccess.new
  #   hash_2[:key] = 'New Value!'
  #
  #   hash_1.update(hash_2) # => {"key"=>"New Value!"}
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new
  #   hash.update({ "a" => 1 }, { "b" => 2 }) # => { "a" => 1, "b" => 2 }
  #
  # The arguments can be either an
  # +ActiveSupport::HashWithIndifferentAccess+ or a regular +Hash+.
  # In either case the merge respects the semantics of indifferent access.
  #
  # If the argument is a regular hash with keys +:key+ and <tt>"key"</tt> only one
  # of the values end up in the receiver, but which one is unspecified.
  #
  # When given a block, the value for duplicated keys will be determined
  # by the result of invoking the block with the duplicated key, the value
  # in the receiver, and the value in +other_hash+. The rules for duplicated
  # keys follow the semantics of indifferent access:
  #
  #   hash_1[:key] = 10
  #   hash_2['key'] = 12
  #   hash_1.update(hash_2) { |key, old, new| old + new } # => {"key"=>22}
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#132
  def update(*other_hashes, &block); end

  # Returns an array of the values at the specified indices:
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new
  #   hash[:a] = 'x'
  #   hash[:b] = 'y'
  #   hash.values_at('a', 'b') # => ["x", "y"]
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#237
  def values_at(*keys); end

  # Like +merge+ but the other way around: Merges the receiver into the
  # argument and returns a new hash with indifferent access as result:
  #
  #   hash = ActiveSupport::HashWithIndifferentAccess.new
  #   hash['a'] = nil
  #   hash.reverse_merge(a: 0, b: 1) # => {"a"=>nil, "b"=>1}
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#283
  def with_defaults(other_hash); end

  # Same semantics as +reverse_merge+ but modifies the receiver in-place.
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#289
  def with_defaults!(other_hash); end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#62
  def with_indifferent_access; end

  # Returns a hash with indifferent access that includes everything except given keys.
  #   hash = { a: "x", b: "y", c: 10 }.with_indifferent_access
  #   hash.except(:a, "b") # => {c: 10}.with_indifferent_access
  #   hash                 # => { a: "x", b: "y", c: 10 }.with_indifferent_access
  #
  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#311
  def without(*keys); end

  private

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#395
  def convert_key(key); end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#399
  def convert_value(value, conversion: T.unsafe(nil)); end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#416
  def set_defaults(target); end

  # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#424
  def update_with_single_argument(other_hash, block); end

  class << self
    # source://activesupport//lib/active_support/hash_with_indifferent_access.rb#85
    def [](*args); end
  end
end

# source://activesupport//lib/active_support/hash_with_indifferent_access.rb#342
ActiveSupport::HashWithIndifferentAccess::NOT_GIVEN = T.let(T.unsafe(nil), Object)

# source://activesupport//lib/active_support/core_ext/hash/keys.rb#3
class Hash
  include ::Enumerable

  # Validates all keys in a hash match <tt>*valid_keys</tt>, raising
  # +ArgumentError+ on a mismatch.
  #
  # Note that keys are treated differently than HashWithIndifferentAccess,
  # meaning that string and symbol keys will not match.
  #
  #   { name: 'Rob', years: '28' }.assert_valid_keys(:name, :age) # => raises "ArgumentError: Unknown key: :years. Valid keys are: :name, :age"
  #   { name: 'Rob', age: '28' }.assert_valid_keys('name', 'age') # => raises "ArgumentError: Unknown key: :name. Valid keys are: 'name', 'age'"
  #   { name: 'Rob', age: '28' }.assert_valid_keys(:name, :age)   # => passes, raises nothing
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#48
  def assert_valid_keys(*valid_keys); end

  # Returns a new hash with all keys converted to strings.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  #
  #   hash = { person: { name: 'Rob', age: '28' } }
  #
  #   hash.deep_stringify_keys
  #   # => {"person"=>{"name"=>"Rob", "age"=>"28"}}
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#84
  def deep_stringify_keys; end

  # Destructively converts all keys to strings.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#91
  def deep_stringify_keys!; end

  # Returns a new hash with all keys converted to symbols, as long as
  # they respond to +to_sym+. This includes the keys from the root hash
  # and from all nested hashes and arrays.
  #
  #   hash = { 'person' => { 'name' => 'Rob', 'age' => '28' } }
  #
  #   hash.deep_symbolize_keys
  #   # => {:person=>{:name=>"Rob", :age=>"28"}}
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#103
  def deep_symbolize_keys; end

  # Destructively converts all keys to symbols, as long as they respond
  # to +to_sym+. This includes the keys from the root hash and from all
  # nested hashes and arrays.
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#110
  def deep_symbolize_keys!; end

  # Returns a new hash with all keys converted by the block operation.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  #
  #   hash = { person: { name: 'Rob', age: '28' } }
  #
  #   hash.deep_transform_keys{ |key| key.to_s.upcase }
  #   # => {"PERSON"=>{"NAME"=>"Rob", "AGE"=>"28"}}
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#65
  def deep_transform_keys(&block); end

  # Destructively converts all keys by using the block operation.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#72
  def deep_transform_keys!(&block); end

  # Removes the given keys from hash and returns it.
  #   hash = { a: true, b: false, c: nil }
  #   hash.except!(:c) # => { a: true, b: false }
  #   hash             # => { a: true, b: false }
  #
  # source://activesupport//lib/active_support/core_ext/hash/except.rb#20
  def except!(*keys); end

  # Removes and returns the key/value pairs matching the given keys.
  #
  #   hash = { a: 1, b: 2, c: 3, d: 4 }
  #   hash.extract!(:a, :b) # => {:a=>1, :b=>2}
  #   hash                  # => {:c=>3, :d=>4}
  #
  # source://activesupport//lib/active_support/core_ext/hash/slice.rb#24
  def extract!(*keys); end

  # Merges the caller into +other_hash+. For example,
  #
  #   options = options.reverse_merge(size: 25, velocity: 10)
  #
  # is equivalent to
  #
  #   options = { size: 25, velocity: 10 }.merge(options)
  #
  # This is particularly useful for initializing an options hash
  # with default values.
  #
  # source://activesupport//lib/active_support/core_ext/hash/reverse_merge.rb#14
  def reverse_merge(other_hash); end

  # Destructive +reverse_merge+.
  #
  # source://activesupport//lib/active_support/core_ext/hash/reverse_merge.rb#20
  def reverse_merge!(other_hash); end

  # Destructive +reverse_merge+.
  #
  # source://activesupport//lib/active_support/core_ext/hash/reverse_merge.rb#20
  def reverse_update(other_hash); end

  # Replaces the hash with only the given keys.
  # Returns a hash containing the removed key/value pairs.
  #
  #   hash = { a: 1, b: 2, c: 3, d: 4 }
  #   hash.slice!(:a, :b)  # => {:c=>3, :d=>4}
  #   hash                 # => {:a=>1, :b=>2}
  #
  # source://activesupport//lib/active_support/core_ext/hash/slice.rb#10
  def slice!(*keys); end

  # Returns a new hash with all keys converted to strings.
  #
  #   hash = { name: 'Rob', age: '28' }
  #
  #   hash.stringify_keys
  #   # => {"name"=>"Rob", "age"=>"28"}
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#10
  def stringify_keys; end

  # Destructively converts all keys to strings. Same as
  # +stringify_keys+, but modifies +self+.
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#16
  def stringify_keys!; end

  # Returns a new hash with all keys converted to symbols, as long as
  # they respond to +to_sym+.
  #
  #   hash = { 'name' => 'Rob', 'age' => '28' }
  #
  #   hash.symbolize_keys
  #   # => {:name=>"Rob", :age=>"28"}
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#27
  def symbolize_keys; end

  # Destructively converts all keys to symbols, as long as they respond
  # to +to_sym+. Same as +symbolize_keys+, but modifies +self+.
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#34
  def symbolize_keys!; end

  # Returns a new hash with all keys converted to symbols, as long as
  # they respond to +to_sym+.
  #
  #   hash = { 'name' => 'Rob', 'age' => '28' }
  #
  #   hash.symbolize_keys
  #   # => {:name=>"Rob", :age=>"28"}
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#27
  def to_options; end

  # Destructively converts all keys to symbols, as long as they respond
  # to +to_sym+. Same as +symbolize_keys+, but modifies +self+.
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#34
  def to_options!; end

  # Merges the caller into +other_hash+. For example,
  #
  #   options = options.reverse_merge(size: 25, velocity: 10)
  #
  # is equivalent to
  #
  #   options = { size: 25, velocity: 10 }.merge(options)
  #
  # This is particularly useful for initializing an options hash
  # with default values.
  #
  # source://activesupport//lib/active_support/core_ext/hash/reverse_merge.rb#14
  def with_defaults(other_hash); end

  # Destructive +reverse_merge+.
  #
  # source://activesupport//lib/active_support/core_ext/hash/reverse_merge.rb#20
  def with_defaults!(other_hash); end

  private

  # Support methods for deep transforming nested hashes and arrays.
  #
  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#116
  def _deep_transform_keys_in_object(object, &block); end

  # source://activesupport//lib/active_support/core_ext/hash/keys.rb#129
  def _deep_transform_keys_in_object!(object, &block); end
end

# :stopdoc:
#
# source://activesupport//lib/active_support/hash_with_indifferent_access.rb#441
HashWithIndifferentAccess = ActiveSupport::HashWithIndifferentAccess

class LoadError < ::ScriptError
  include ::DidYouMean::Correctable
end

# == Attribute Accessors per Thread
#
# Extends the module object with class/module and instance accessors for
# class/module attributes, just like the native attr* accessors for instance
# attributes, but does so on a per-thread basis.
#
# So the values are scoped within the Thread.current space under the class name
# of the module.
#
# Note that it can also be scoped per-fiber if +Rails.application.config.active_support.isolation_level+
# is set to +:fiber+.
#
# source://activesupport//lib/active_support/core_ext/module/delegation.rb#3
class Module
  # Provides a +delegate+ class method to easily expose contained objects'
  # public methods as your own.
  #
  # ==== Options
  # * <tt>:to</tt> - Specifies the target object name as a symbol or string
  # * <tt>:prefix</tt> - Prefixes the new method with the target name or a custom prefix
  # * <tt>:allow_nil</tt> - If set to true, prevents a +ActiveSupport::DelegationError+
  #   from being raised
  # * <tt>:private</tt> - If set to true, changes method visibility to private
  #
  # The macro receives one or more method names (specified as symbols or
  # strings) and the name of the target object via the <tt>:to</tt> option
  # (also a symbol or string).
  #
  # Delegation is particularly useful with Active Record associations:
  #
  #   class Greeter < ActiveRecord::Base
  #     def hello
  #       'hello'
  #     end
  #
  #     def goodbye
  #       'goodbye'
  #     end
  #   end
  #
  #   class Foo < ActiveRecord::Base
  #     belongs_to :greeter
  #     delegate :hello, to: :greeter
  #   end
  #
  #   Foo.new.hello   # => "hello"
  #   Foo.new.goodbye # => NoMethodError: undefined method `goodbye' for #<Foo:0x1af30c>
  #
  # Multiple delegates to the same target are allowed:
  #
  #   class Foo < ActiveRecord::Base
  #     belongs_to :greeter
  #     delegate :hello, :goodbye, to: :greeter
  #   end
  #
  #   Foo.new.goodbye # => "goodbye"
  #
  # Methods can be delegated to instance variables, class variables, or constants
  # by providing them as a symbols:
  #
  #   class Foo
  #     CONSTANT_ARRAY = [0,1,2,3]
  #     @@class_array  = [4,5,6,7]
  #
  #     def initialize
  #       @instance_array = [8,9,10,11]
  #     end
  #     delegate :sum, to: :CONSTANT_ARRAY
  #     delegate :min, to: :@@class_array
  #     delegate :max, to: :@instance_array
  #   end
  #
  #   Foo.new.sum # => 6
  #   Foo.new.min # => 4
  #   Foo.new.max # => 11
  #
  # It's also possible to delegate a method to the class by using +:class+:
  #
  #   class Foo
  #     def self.hello
  #       "world"
  #     end
  #
  #     delegate :hello, to: :class
  #   end
  #
  #   Foo.new.hello # => "world"
  #
  # Delegates can optionally be prefixed using the <tt>:prefix</tt> option. If the value
  # is <tt>true</tt>, the delegate methods are prefixed with the name of the object being
  # delegated to.
  #
  #   Person = Struct.new(:name, :address)
  #
  #   class Invoice < Struct.new(:client)
  #     delegate :name, :address, to: :client, prefix: true
  #   end
  #
  #   john_doe = Person.new('John Doe', 'Vimmersvej 13')
  #   invoice = Invoice.new(john_doe)
  #   invoice.client_name    # => "John Doe"
  #   invoice.client_address # => "Vimmersvej 13"
  #
  # It is also possible to supply a custom prefix.
  #
  #   class Invoice < Struct.new(:client)
  #     delegate :name, :address, to: :client, prefix: :customer
  #   end
  #
  #   invoice = Invoice.new(john_doe)
  #   invoice.customer_name    # => 'John Doe'
  #   invoice.customer_address # => 'Vimmersvej 13'
  #
  # The delegated methods are public by default.
  # Pass <tt>private: true</tt> to change that.
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :first_name, to: :profile
  #     delegate :date_of_birth, to: :profile, private: true
  #
  #     def age
  #       Date.today.year - date_of_birth.year
  #     end
  #   end
  #
  #   User.new.first_name # => "Tomas"
  #   User.new.date_of_birth # => NoMethodError: private method `date_of_birth' called for #<User:0x00000008221340>
  #   User.new.age # => 2
  #
  # If the target is +nil+ and does not respond to the delegated method a
  # +ActiveSupport::DelegationError+ is raised. If you wish to instead return +nil+,
  # use the <tt>:allow_nil</tt> option.
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :age, to: :profile
  #   end
  #
  #   User.new.age
  #   # => ActiveSupport::DelegationError: User#age delegated to profile.age, but profile is nil
  #
  # But if not having a profile yet is fine and should not be an error
  # condition:
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :age, to: :profile, allow_nil: true
  #   end
  #
  #   User.new.age # nil
  #
  # Note that if the target is not +nil+ then the call is attempted regardless of the
  # <tt>:allow_nil</tt> option, and thus an exception is still raised if said object
  # does not respond to the method:
  #
  #   class Foo
  #     def initialize(bar)
  #       @bar = bar
  #     end
  #
  #     delegate :name, to: :@bar, allow_nil: true
  #   end
  #
  #   Foo.new("Bar").name # raises NoMethodError: undefined method `name'
  #
  # The target method must be public, otherwise it will raise +NoMethodError+.
  #
  # source://activesupport//lib/active_support/core_ext/module/delegation.rb#160
  def delegate(*methods, to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil), private: T.unsafe(nil)); end

  # When building decorators, a common pattern may emerge:
  #
  #   class Partition
  #     def initialize(event)
  #       @event = event
  #     end
  #
  #     def person
  #       detail.person || creator
  #     end
  #
  #     private
  #       def respond_to_missing?(name, include_private = false)
  #         @event.respond_to?(name, include_private)
  #       end
  #
  #       def method_missing(method, *args, &block)
  #         @event.send(method, *args, &block)
  #       end
  #   end
  #
  # With <tt>Module#delegate_missing_to</tt>, the above is condensed to:
  #
  #   class Partition
  #     delegate_missing_to :@event
  #
  #     def initialize(event)
  #       @event = event
  #     end
  #
  #     def person
  #       detail.person || creator
  #     end
  #   end
  #
  # The target can be anything callable within the object, e.g. instance
  # variables, methods, constants, etc.
  #
  # The delegated method must be public on the target, otherwise it will
  # raise +ActiveSupport::DelegationError+. If you wish to instead return +nil+,
  # use the <tt>:allow_nil</tt> option.
  #
  # The <tt>marshal_dump</tt> and <tt>_dump</tt> methods are exempt from
  # delegation due to possible interference when calling
  # <tt>Marshal.dump(object)</tt>, should the delegation target method
  # of <tt>object</tt> add or remove instance variables.
  #
  # source://activesupport//lib/active_support/core_ext/module/delegation.rb#218
  def delegate_missing_to(target, allow_nil: T.unsafe(nil)); end
end

# source://activesupport//lib/active_support/core_ext/module/delegation.rb#5
Module::DelegationError = ActiveSupport::DelegationError

class NameError < ::StandardError
  include ::ErrorHighlight::CoreExt
  include ::DidYouMean::Correctable
end
